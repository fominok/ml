(ns naive.core
  (:require [clojure.data.csv :as csv]
            [clojure.java.io :as io]
            [clojure.core.matrix :as m])
  (:gen-class))

(defn deep-merge [a b]
  (merge-with (fn [x y]
                (cond (map? y) (deep-merge x y) 
                      (vector? y) (concat x y) 
                      :else y)) 
                 a b))

(defn load-data [filename]
  (with-open [reader (io/reader filename)]
    (doall (csv/read-csv reader))))

(defn -main [& args]
  (let [train-data (-> (load-data "data_train.csv")
                       (m/submatrix 0 70 2 17)
                       (fn [d] (map #(map read-string %) d))
                       m/array)])
  (println "Hello, World!"))

(defn sinc [x]
  "Safe increment"
  (if x (inc x) 1))

(def quants
  (reduce (fn [bacc row]
            (let [cl (last row)
                  params (subvec row 0 (dec (count row)))]
              (update-in (reduce (fn [sacc [i p]] (update-in sacc [cl i p] sinc)) bacc
                                 (map-indexed (fn [i p] [i p]) params))
                         [cl :sum] sinc))) {} data))

(def class-prob (reduce (fn [acc [k v]] (assoc acc k (/ (:sum v) 70))) {} quants))

(def prop-on-class-prob
  (reduce (fn [bacc [cls params]]
            (let [s (:sum cls)]
              (reduce (fn [sacc [param values]]
                        (if (= param :sum)
                          sacc
                          (reduce (fn [ssacc [v q]]
                                    (assoc-in ssacc [cls param v] (/ q s))) sacc values)))
                      bacc params))) {} quants))

(clojure.pprint/pprint (into (sorted-map) quants) (io/writer "pretty"))
(clojure.pprint/pprint (into (sorted-map) class-prob) (io/writer "pretty-prob-class"))
